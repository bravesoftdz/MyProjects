uses BlockFileOfT;

type
  r1=record
    b1,b2:byte;
    
    constructor(b1,b2:byte);
    begin
      self.b1 := b1;
      self.b2 := b2;
    end;
    ///Переопределение того - как объекты типа r1 будет выписывать writeln
    function ToString:string; override :=
    $'r1({b1}, {b2})';
  end;
  r2=record
    b:byte;
    i:int64;
  end;

begin
  var f := new BlockFileOf<r1>('temp.bin');
  f.Rewrite;
  
  f.Write(new r1(1,2));
  f.Write(new r1(3,4));
  f.Write(new r1(5,6));
  
  f.Pos := 1;
  writeln(f.BinReader.ReadByte);//3 - прочитало первый байт из второго элемента
  writeln(f.Read);//А вот так делать не надо. Сейчас курсор находится в середите второго элемента
                  //Обычно это вызовет неопределённое поведение и заполнит поля полученной записи мусором
                  //Но этот случай простой, поэтому прочитает половину второй + половину третьей записи и выведет (4,5)
                  //Если используете BinReader, BinWriter или BaseStream - надо удостоверится что всё привели в порядок
                  //К примеру, тут сработает "f.Pos := n" после строчки с "f.BinReader"
  
  f.Pos := 0;
  f.PosByte += 1;//сдвигаем курсор на 1 байт (вся запись f.TSize, что, в данном случае 2)//но это не у всех сработает, почему - в следующем абзаце
  writeln(f.BinReader.ReadByte);//2, потому что второй байт первой записи
  
  f.Close;
  
  var f2 := new BlockFileOf<r2>;
  writeln(f2.TSize);//То же самое что sizeof(r2). У меня 16, хотя byte=1 + int64=8, то есть должно быть 9?
                    //Это потому, что на разных процессорах добавляет свои отступы (так легче читать/записывать) в некоторые записи, так что будьте осторожны
                    //Это так же хорошая причина не пользоваться бездумно BinReader, BinWriter или BaseStream - потому что на разных компьютерах может быть по разному 
  
end.