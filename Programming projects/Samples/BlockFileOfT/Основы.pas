uses BlockFileOfT;

type
  r1=record
    i:integer;
    r:real;
    
    constructor(i:integer; r:real);
    begin
      self.i := i;
      self.r := r;
    end;
    ///Переопределение того - как объекты типа r1 будет выписывать writeln
    function ToString:string; override :=
    $'r1({i}, {r})';
  end;

begin
  //var f: BlockFileOf<r1>;
  //f := new BlockFileOf<r1>;//В отличии от file of T - всегда надо инициализировать перед тем как использовать
  //f.Assign('temp.bin');
  var f := new BlockFileOf<r1>('temp.bin');//эта строчка заменяет предыдущие 3
  
  f.Rewrite;//Если навести мышку на метод (в данном случае Rewrite) - показывает описание
  f.Write(new r1(123,123.456));
  f.Write(new r1(456,456.789));
  //f.Flush;//не обязательно - Close делает то же самое перед тем как закрыть файл
  f.Close;//После работы с файлом - надо его закрыть.
  
  //f.Assign('temp.bin');//Не обязательно, файл остаётся привязан после закрытия
  
  f.Reset;
  writeln($'Read#1: {f.Read}');//r1(123,123.456)
  
  writeln($'Pos#1: {f.Pos}');//1, потому что мы открыли файл через "Reset" (курсор вначале файла) и затем прочитали 1 элемент
  
  f.Write(new r1(0,0));//В отличии от file of T, у BlockFileOf<T> нету режима чтения и режима записи
                       //Они объеденены, поэтому не надо закрывать файл чтоб записать что то после чтения
  
  writeln($'Size#1: {f.Size}');//2, потому что r1(0,0) не втиснуло между первыми 2 элементами, а записало поверх второго
  
  writeln($'EOF: {f.EOF}');//True, потому что у нас всего было 2 элемента, и курсор сейчас стоит на позиции 2 (1 чтение + 1 запись)
  
  //f.Seek(1);
  f.Pos := 1;//то же самое что и Seek(1)
  
  writeln($'Read#2: {f.Read}');//r1(0,0), то, что мы только что записали
  
  f.Pos := 5;//Можно ставить за границей файла
  //f.Read;//Ошибка: Нельзя читать за пределами файла. Можно только записывать
  f.Write(new r1);
  writeln($'Size#2: {f.Size}');//6, потому что мы записали +1 элемент после позиции 5
  
  f.Size := 10;//Можно и так, в этом случае не надо ничего записывать
  writeln($'Size#3: {f.Size}');//10
  writeln($'Pos#2: {f.Pos}');//6, как и была после того как мы последний раз вызвали f.Write
  
  f.Flush;//Программа сейчас завершится, поэтому файл закроется сам
          //Но если не вызвать хотя бы Flush - изменения могут не сохранится
  
end.